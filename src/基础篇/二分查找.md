# 二分查找

二分查找（Binary Search）算法，也叫折半查找算法。

二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

二分查找的时间复杂度为 `O(logn) `。

例如想在下面的序列中查找19：

![](./img/binary_search.png)

## 二分查找的实现

最简单的情况就是有序数组中不存在重复元素：

```
int search(vector<int> nums, int target)
{
    int left = 0, right = nums.size() - 1;
    while (left <= right)
    {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target)
        	return mid;
        else if (nums[mid] > target)
       		right = mid - 1;
        else
        	left = mid + 1;
    }
    return -1;
}
```

- 二分区间：`[0,size)`
- 向左查找：`right=mid-1`；向右查找：`left=mid+1`
- 循环结束条件是：`left>right` 即 `left=right+1`

 递归实现：

```
int search(vector<int> arr, int low, int high, int target)
{
	if (low > high)
		return -1;
	int mid = low + ((high - low) >> 1);
	if (arr[mid] == target)
		return mid;
	else if (arr[mid] < target)
		return search(arr, mid + 1, high, target);
	else
		return search(arr, low, mid - 1, target);
}
```

## 二分查找应用场景的局限性

### 二分查找依赖的是顺序表结构，即数组



