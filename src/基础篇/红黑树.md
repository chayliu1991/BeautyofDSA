# 红黑树

## 平衡二叉查找树

二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 `O(logn)`。但二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 `logn`  的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 `O(n)`。要解决这个复杂度退化的问题，需要设计一种平衡二叉查找树。

平衡二叉树的严格定义是任意一个节点的左右子树的高度相差不能大于 1。

完全二叉树、满二叉树都是平衡二叉树，非完全二叉树也有可能是平衡二叉树。

![](./img/balance_tree.png)

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

所以，平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

## 红黑树

红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，红黑树中的节点，一类被标记为黑色，一类被标记为红色。

### 红黑树所需要满足的要求

- 根节点是黑色的
- 每个叶子节点都是黑色的空节点（NIL），叶子节点不存储数据
- 任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的
- 每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点

![](./img/rb_tree.png)

### 红黑树的“近似平衡”

平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 `logn`，红黑树是否近似平衡就看红黑树的高度是否比较稳定地趋近 `logn` 。

### 实现红黑树的基本思想

把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。

找准关注节点，不要搞丢、搞错关注节点。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。

插入操作的平衡调整比较简单，但是删除操作就比较复杂。针对删除操作，有两次调整

- 第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。
- 第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。

### 平衡操作中两个非常重要的操作

- 左旋（rotate left）全称叫围绕某个节点的左旋
- 右旋（rotate right）全称叫围绕某个节点的右旋

![](./img/rotate.png)

### 插入操作的平衡调整

红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。

插入操作的平衡调整，有这样两种特殊情况：

- 如果插入节点的父节点是黑色的，无需任何调整。
- 如果插入的节点是根节点，那就直接把它改成黑色就可以了。

其他情况都需要进行调整，调整的过程包含两种基础的操作：左右旋转和改变颜色。

红黑树的平衡调整是一个迭代的过程。正在被处理的节点叫**关注节点**，关注节点会随着不停地迭代处理，而不断发生变化，最开始的关注节点就是新插入的节点。

新节点插入之后，如果红黑树的平衡被打破一般会有下面三种情况。只需要根据每种情况采取对应的策略去调整，然后不停的迭代，就可以让红黑树继续符合定义从而保持平衡。

下面把父节点的兄弟节点称为**叔叔节点**，父节点的父节点称为**祖父节点**。

#### CASE 1：关注节点 a的叔叔节点 d 是红色

- 将关注节点 a 的父节点 b、叔叔节点 d 都设置成黑色
- 将关注节点 a 的祖父节点 c 设置成红色
- 关注节点变成 a 的祖父节点 c
- 跳到 CASE 2 或者 CASE 3

![](./img/rb_tree_insert_case1.png)

#### CASE 2：关注节点 a的叔叔节点 d 是黑色，而且节点 a是其父节点的右子节点：

- 关注节点变成节点 a 的父节点 b
- 围绕新的关注节点b 左旋
- 跳到 CASE 3

如果关注节点 的叔叔节点是黑色而且是右子节点，就将关注节点设置为关注节点的父节点并左旋，最后跳到 CASE 3

![](./img/rb_tree_insert_case2.png)

#### CASE 3：关注节点a的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点

- 围绕关注节点 a 的祖父节点 c 右旋
- 将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换
- 调整结束

如果关注节点 的叔叔节点是黑色而且是左子节点，就围绕关注节点的祖父节点右旋，最后将关注节点的父节点 与关注节点的兄弟节点 颜色互换

![](./img/rb_tree_insert_case3.png)

### 删除操作的平衡调整

删除操作的平衡调整分为两步：

- 初步调整：调整到每个节点到达其可达叶子节点的所有路径包含黑色节点的个数要相等
- 二次调整：调整到不存在相邻的两个红色节点

#### 初步调整

经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。

图示说明：如果一个节点既可以是红色也可以是黑色，用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，用左上角的一个小黑点来表示额外的黑色。

##### CASE 1：要删除的节点 a只有一个子节点 b

节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。节点b替换到节点 a 的位置并把节点 a 删除，然后将节点b的颜色设置为黑色。

![](./img/rb_tree_delete_case1.png)

##### CASE 2：要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c

节点 a 的后继节点是右子节点 c表示右子节点 c没有左子树。

- 将后继节点 c 替换到节点 a 的位置并把节点 a 删除
- 节点 c 设置为跟节点 a 相同的颜色
- 如果节点 c 是黑色，就给节点 c 的右子节点 d 多加一个黑色，节点 d 就成了“红 - 黑”或者“黑 - 黑”
- 关注节点设置为节点 d，准备进行二次调整

![](./img/rb_tree_delete_case2.png)

##### CASE 3：要删除的节点 a有两个非空子节点，并且节点 a 的后继节点不是右子节点

节点 a 的后继节点不是右子节点表示右子节点存在左子树。

- 将节点 a 的数据修改为后继节点 d的数据，然后按照CASE 1删除后继节点 d 
- 如果节点a 是黑色，给节点 a 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”
- 关注节点设置为节点 c，准备进行二次调整

![](./img/rb_tree_delete_case3.png)

#### 二次调整

经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，需要再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。

##### CASE 1：关注节点 a的兄弟节点 c 是红色

- 围绕关注节点 a 的父节点 b 左旋
- 关注节点 a 的父节点 b 和祖父节点 c 交换颜色
- 关注节点不变，继续从四种情况中选择适合的规则来调整

![](./img/rb_tree_delete2_case1.png)

##### CASE 2：关注节点 a的兄弟节点 c 是黑色，并且节点 c 的左右子节点 d、e 都是黑色

- 将关注节点 a 的兄弟节点 c设置为红色
- 从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色
- 给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”
- 关注节点从 a 变成其父节点 b
- 继续从四种情况中选择符合的规则来调整

![](./img/rb_tree_delete2_case2.png)

##### CASE 3：关注节点a的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色

- 围绕关注节点 a 的兄弟节点 c 右旋
- 节点 c 和节点 d 交换颜色
- 关注节点不变，跳到 CASE 4，继续调整

![](./img/rb_tree_delete2_case3.png)

##### CASE 4：关注节点 a 的兄弟节点 c 是黑色，并且兄弟节点c 的右子节点是红色的

- 围绕关注节点 a 的父节点 b 左旋
- 将关注节点 a 的兄弟节点 c 设置为跟关注节点 a 的父节点 b 相同的颜色
- 将关注节点 a 的父节点 b 和叔叔节点 e 设置为黑色
- 去掉关注节点 a 的一个黑色，节点 a 就变成了单纯的红色或者黑色
- 调整结束

![](./img/rb_tree_delete2_case4.png)

### 为什么红黑树要求叶子节点是黑色的空节点？

假设红黑树不要求“叶子节点必须是黑色的空节点”，当插入节点的父节点也是红色的时候，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。这个时候，新插入的节点没有叔叔节点，三种情况下的平衡调整规则就都不适用的。

![](./img/rb_tree_insert_node.png)

但如果把黑色的空节点都给它加上，就可以满足 CASE 2 ：

![](./img/rb_tree_insert_node2.png)

CASE 2 可以改为“关注节点 a的叔叔节点 d 是黑色或者叔叔节点 d 不存在， a是其父节点的右子节点”，但没有原来的规则简洁。

给红黑树添加黑色的空的叶子节点，并不会太浪费存储空间呢。因为在具体实现的时候，只需共用一个黑色的、空的叶子节点就行了。

![](./img/rb_tree_insert_node3.png)









