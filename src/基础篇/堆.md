# 堆

## 堆的概念

堆是一种特殊的树：

- 堆是一个完全二叉树；
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

堆必须是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。

堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。

- 对于每个节点的值都大于等于子树中每个节点值的堆叫“大顶堆”。
- 对于每个节点的值都小于等于子树中每个节点值的堆叫“小顶堆”。

![](./img/heap.png)

## 存储一个堆

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树，不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![](./img/heap_save.png)

上图中 `i=1` 存储根节点，下标为 `i` 的节点的左子节点就是下标为 `i∗2` 的节点，右子节点就是下标为 `i∗2+1` 的节点，父节点就是下标为`i/2` 的节点。

## 堆的基本操作

一个包含 `n` 个节点的完全二叉树高度小于 `log_{2}n`，堆化的时间复杂度跟树的高度成正比等于 `O(logn)`。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 `O(logn)`。

### 插入一个元素

往堆中插入一个元素后需要继续满足堆的两个特性。

把新插入的元素直接放到堆的最后，之前的堆就不再符合堆的特性。就需要进行调整，让其重新满足堆的特性，这个过程叫作**堆化**（heapify）。

堆化有从下往上和从上往下两种方法。

![](./img/heapify.png)

堆化就是顺着节点所在的路径，向上或者向下进行对比，然后交换。从下往上堆化是让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，就互换两个节点。一直重复这个过程，直到比对到根节点。

![](./img/heapify1.png)

### 删除堆顶元素

堆的任何节点的值都大于等于（或小于等于）子树节点的值，堆顶元素存储的就是堆中数据的最大值或者最小值。

大顶堆的堆顶元素就是最大的元素，删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。

但这样操作完成后的堆不再满足完全二叉树的特性：

![](./img/heap_delete.png)

可以先把最后一个节点放到堆顶，然后从上往下的堆化。这种方法堆化之后的结果，肯定满足完全二叉树的特性：

![](./img/heap_delete2.png)

## 基于堆实现堆排序

借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 `O(nlogn)`，并且它还是原地排序算法。

堆排序的过程可以大致分解成两个大的步骤，**建堆** 和 **排序**。

### 建堆

我们首先将数组原地建成一个堆。“原地”是指不借助另一个数组在原数组上操作。

建堆的两种思路：

- 假设起初堆中只包含一个数据，就是下标为 1 的数据。然后调用插入操作，将下标从 2 到 n 的数据依次插入到堆中。整个过程都是从下到上的堆化。
- 从后往前处理数组，找到第一个\非叶子节点，然后依次从上往下堆化。

![](./img/make_heap.png)











